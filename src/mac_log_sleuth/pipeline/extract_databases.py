#!/usr/bin/env python3

"""
Database Extractor for Forensic Images
by WarpedWing Labs

Extracts database files from forensic images using The Sleuth Kit.
Uses the database list generated by multi_partition_scanner.py.

Usage:
    # Extract specific databases by pattern
    python extract_databases.py \\
        --image /path/to/image.dd \\
        --database-list kb_laptop_scan/partition_2/partition_2_databases.txt \\
        --output extracted_dbs \\
        --patterns "Safari/History.db" "Messages/chat.db" "Chrome/Default/History"

    # Extract all databases (WARNING: 3000+ files!)
    python extract_databases.py \\
        --image /path/to/image.dd \\
        --database-list kb_laptop_scan/partition_2/partition_2_databases.txt \\
        --output extracted_dbs \\
        --all
"""

from __future__ import annotations

import argparse
import hashlib
import json
import re
import shutil
import subprocess
import sys
from pathlib import Path
from typing import Any


class DatabaseExtractor:
    """Extract database files from forensic images using TSK."""

    def __init__(self, image_path: Path, output_dir: Path):
        self.image_path = image_path
        self.output_dir = output_dir
        self.check_dependencies()

        # Track extractions
        self.extracted = []
        self.failed = []

    def check_dependencies(self):
        """Check for required tools."""
        if not shutil.which("icat"):
            print("[ERROR] icat not found. Install with: brew install sleuthkit")
            sys.exit(1)

        if not shutil.which("hdiutil"):
            print("[ERROR] hdiutil not found (macOS built-in tool)")
            sys.exit(1)

        print("[OK] Required tools found")

    def attach_image(self) -> str | None:
        """Attach DD image and return device path."""
        print(f"\n[ATTACH] Attaching {self.image_path.name}...")

        try:
            result = subprocess.run(
                [
                    "hdiutil",
                    "attach",
                    "-nomount",
                    "-imagekey",
                    "diskimage-class=CRawDiskImage",
                    str(self.image_path),
                ],
                check=True,
                capture_output=True,
                text=True,
                timeout=60,
            )

            for line in result.stdout.strip().split("\n"):
                if line.startswith("/dev/disk"):
                    device = line.split()[0]
                    print(f"[OK] Attached as {device}")
                    return device

        except subprocess.CalledProcessError as e:
            print(f"[ERROR] Failed to attach: {e}")

        return None

    def detach_image(self, device: str):
        """Detach the attached image."""
        print(f"\n[DETACH] Detaching {device}...")
        try:
            subprocess.run(["hdiutil", "detach", device], check=True, timeout=30)
            print("[OK] Detached")
        except subprocess.CalledProcessError as e:
            print(f"[WARNING] Failed to detach: {e}")

    def parse_database_list(self, list_file: Path) -> list[dict[str, Any]]:
        """
        Parse database list file from multi_partition_scanner.

        Format: r/r INODE:	PATH
        Example: r/r 744691:	Users/admin/Library/Safari/History.db
        """
        databases = []

        with open(list_file) as f:
            for line in f:
                line = line.strip()
                if not line:
                    continue

                # Parse: r/r INODE: PATH
                match = re.match(r"r/r\s+(\d+):\s+(.+)", line)
                if match:
                    inode = int(match.group(1))
                    path = match.group(2)

                    databases.append({"inode": inode, "path": path, "name": Path(path).name})

        print(f"[INFO] Parsed {len(databases)} database entries")
        return databases

    def filter_databases(
        self, databases: list[dict[str, Any]], patterns: list[str]
    ) -> list[dict[str, Any]]:
        """Filter databases by path patterns."""
        if not patterns:
            return databases

        filtered = []
        for db in databases:
            path_lower = db["path"].lower()
            if any(pattern.lower() in path_lower for pattern in patterns):
                filtered.append(db)

        print(f"[INFO] Filtered to {len(filtered)} databases matching patterns")
        return filtered

    def extract_database(
        self, device: str, partition: int, inode: int, path: str, output_path: Path
    ) -> bool:
        """
        Extract a single database file using icat.

        Args:
            device: Device path (e.g., /dev/disk5)
            partition: Partition number
            inode: Inode number of the file
            path: Original path (for logging)
            output_path: Where to save the file

        Returns:
            True if extraction succeeded
        """
        target = f"{device}s{partition}"

        print(f"[EXTRACT] {path}")
        print(f"          Inode: {inode}")
        print(f"          Target: {target}")
        print(f"          Output: {output_path.name}")

        # Create output directory
        output_path.parent.mkdir(parents=True, exist_ok=True)

        try:
            # Use icat to extract file by inode
            with open(output_path, "wb") as f:
                result = subprocess.run(
                    ["icat", target, str(inode)],
                    check=True,
                    stdout=f,
                    stderr=subprocess.PIPE,
                    timeout=60,
                )

            # Verify file was created and has content
            if output_path.exists() and output_path.stat().st_size > 0:
                size_mb = output_path.stat().st_size / 1024 / 1024
                print(f"[OK] Extracted ({size_mb:.2f} MB)")

                # Compute hash for forensic integrity
                md5_hash = self._compute_md5(output_path)
                print(f"[HASH] MD5: {md5_hash}")

                return True
            else:
                print("[ERROR] File empty or not created")
                return False

        except subprocess.CalledProcessError as e:
            print(f"[ERROR] Extraction failed: {e}")
            if e.stderr:
                print(f"        {e.stderr.decode('utf-8', errors='ignore')}")
            return False
        except subprocess.TimeoutExpired:
            print("[ERROR] Extraction timed out")
            return False

    def _compute_md5(self, file_path: Path) -> str:
        """Compute MD5 hash of a file."""
        md5 = hashlib.md5()
        with open(file_path, "rb") as f:
            for chunk in iter(lambda: f.read(8192), b""):
                md5.update(chunk)
        return md5.hexdigest()

    def extract_all(
        self,
        device: str,
        partition: int,
        databases: list[dict[str, Any]],
        preserve_paths: bool = False,
    ):
        """
        Extract all databases in the list.

        Args:
            device: Device path
            partition: Partition number
            databases: List of database info dicts
            preserve_paths: If True, preserve original directory structure
        """
        print(f"\n[START] Extracting {len(databases)} databases...")

        for i, db in enumerate(databases, 1):
            print(f"\n[{i}/{len(databases)}]")

            if preserve_paths:
                # Preserve original path structure
                rel_path = Path(db["path"])
                output_path = self.output_dir / rel_path
            else:
                # Flat structure with sanitized names
                # Replace slashes with underscores to flatten
                safe_name = db["path"].replace("/", "_")
                output_path = self.output_dir / safe_name

            success = self.extract_database(
                device, partition, db["inode"], db["path"], output_path
            )

            if success:
                self.extracted.append(
                    {
                        "inode": db["inode"],
                        "original_path": db["path"],
                        "extracted_to": str(output_path),
                        "md5": self._compute_md5(output_path),
                        "size_bytes": output_path.stat().st_size,
                    }
                )
            else:
                self.failed.append(
                    {"inode": db["inode"], "original_path": db["path"], "reason": "Extraction failed"}
                )

        # Save extraction report
        self._save_report()

    def _save_report(self):
        """Save extraction report."""
        report = {
            "image": str(self.image_path),
            "output_dir": str(self.output_dir),
            "total_attempted": len(self.extracted) + len(self.failed),
            "successfully_extracted": len(self.extracted),
            "failed": len(self.failed),
            "extracted_files": self.extracted,
            "failed_files": self.failed,
        }

        report_path = self.output_dir / "extraction_report.json"
        with open(report_path, "w") as f:
            json.dump(report, f, indent=2)

        print(f"\n[REPORT] Saved to {report_path}")
        print(f"[SUMMARY] Extracted: {len(self.extracted)}, Failed: {len(self.failed)}")


def main():
    parser = argparse.ArgumentParser(
        description="Extract databases from forensic images using TSK"
    )
    parser.add_argument("--image", type=Path, required=True, help="Path to DD image")
    parser.add_argument(
        "--database-list",
        type=Path,
        required=True,
        help="Database list file from multi_partition_scanner",
    )
    parser.add_argument(
        "--output",
        type=Path,
        default=Path("./extracted_databases"),
        help="Output directory for extracted files",
    )
    parser.add_argument(
        "--partition", type=int, default=2, help="Partition number (default: 2)"
    )
    parser.add_argument(
        "--patterns",
        nargs="+",
        help='Patterns to match (e.g., "Safari" "Chrome" "Messages")',
    )
    parser.add_argument(
        "--all", action="store_true", help="Extract ALL databases (may be many!)"
    )
    parser.add_argument(
        "--preserve-paths",
        action="store_true",
        help="Preserve original directory structure",
    )
    parser.add_argument(
        "--yes",
        "-y",
        action="store_true",
        help="Skip confirmation prompts",
    )

    args = parser.parse_args()

    if not args.image.exists():
        print(f"[ERROR] Image not found: {args.image}")
        sys.exit(1)

    if not args.database_list.exists():
        print(f"[ERROR] Database list not found: {args.database_list}")
        sys.exit(1)

    if not args.all and not args.patterns:
        print("[ERROR] Must specify either --all or --patterns")
        print("\nExample:")
        print('  --patterns "Safari/History" "Messages/chat" "Chrome/History"')
        sys.exit(1)

    # Create extractor
    extractor = DatabaseExtractor(args.image, args.output)

    # Parse database list
    databases = extractor.parse_database_list(args.database_list)

    if not databases:
        print("[ERROR] No databases found in list")
        sys.exit(1)

    # Filter if patterns specified
    if not args.all:
        databases = extractor.filter_databases(databases, args.patterns)

        if not databases:
            print("[ERROR] No databases matched the patterns")
            sys.exit(1)

    # Warn if extracting many files
    if len(databases) > 100 and not args.yes:
        print(f"\n[WARNING] About to extract {len(databases)} files!")
        response = input("Continue? (y/n): ").strip().lower()
        if response != "y":
            print("Cancelled.")
            sys.exit(0)
    elif len(databases) > 100:
        print(f"\n[INFO] Extracting {len(databases)} files (--yes flag set)...")

    # Attach image
    device = extractor.attach_image()
    if not device:
        print("[ERROR] Failed to attach image")
        sys.exit(1)

    try:
        # Extract databases
        extractor.extract_all(device, args.partition, databases, args.preserve_paths)

        print(f"\n[OK] Extraction complete!")
        print(f"[OUTPUT] {args.output}")

    finally:
        # Always detach
        extractor.detach_image(device)


if __name__ == "__main__":
    main()
